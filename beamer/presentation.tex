\documentclass{beamer}
\input{prelude.tex}
\UseRawInputEncoding

\title{Haskelleene: A Very Haskell Implementation of Regular Expressions and Finite Automata Equivalence}
\author{Liam Chung, Brendan Dufty, Lingyuan Ye}
\date{31st May, 2024}

\AtBeginSection[] {
\begin{frame}{Table of Contents}
\begin{columns}[t]
    \begin{column}{.5\textwidth}
        \tableofcontents[sections={1-4}, currentsection, hideallsubsections]
    \end{column}
    \begin{column}{.5\textwidth}
        \tableofcontents[sections={5-8}, currentsection, hideallsubsections]
    \end{column}
\end{columns}
\end{frame}
}

\begin{document}
\frame{\titlepage}

\begin{frame}{Table of Contents}
\begin{columns}[t]
    \begin{column}{.5\textwidth}
        \tableofcontents[sections={1-4}, hideallsubsections]
    \end{column}
    \begin{column}{.5\textwidth}
        \tableofcontents[sections={5-8}, hideallsubsections]
    \end{column}
\end{columns}
\end{frame}

\section{Introduction}
    \begin{frame}{Introduction}
        \begin{quote}
            "Automata are pretty cool."
        \end{quote}
        - Liam Chung
    \end{frame}

    \begin{frame}{Motivation: What Do We Do These Things That We Do?}
      this is some test that is gonna go here to talk about why we do be doing things that we do be doing
    \end{frame}

    \begin{frame}{Motivation: more stuff?}
      look at this this is more stuff that we do

      wanna see a trick?

      check this out: \pause $\smiley$
    \end{frame}

\section{Finite Automata}
  \begin{frame}
    \frametitle{Deterministic Automata}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Non-Deterministic Automata}
    For non-deterministic automata (NA), the transition for an input gives a \emph{list} of next states, and we also allow empty input. \pause
    
    For instance, the following represents a NA:
    \[
      \begin{tikzcd}
        1 & 2 \\
        3 & 4
        \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
        \arrow["b"{description}, from=1-1, to=2-1]
        \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
        \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
        \arrow["a"{description}, from=1-2, to=2-1]
        \arrow["\epsilon"{description}, from=1-2, to=2-2] 
      \end{tikzcd}
    \]
    \vspace{-\baselineskip} \pause

    Our Haskell implementation of the type of NA:
    \begin{showCode}
data NDetAut l s = NA { nstates :: [s]
                      , naccept :: [s]
                      , ndelta :: Maybe l -> s -> [s] }
    \end{showCode}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Semantics of Non-Deterministic Automata}
    \begin{definition}
      A NA accepts an input string $u$ if there is a \emph{possible} path that terminates at an accepting state.
    \end{definition} \pause

    Suppose the initial state is 1, and the only accepting state is 4:
    \[
      \begin{tikzcd}
        1 & 2 \\
        3 & {\color{red} 4}
        \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
        \arrow["b"{description}, from=1-1, to=2-1]
        \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
        \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
        \arrow["a"{description}, from=1-2, to=2-1]
        \arrow["\epsilon"{description}, from=1-2, to=2-2] 
      \end{tikzcd}
    \]
    Then this NA accepts 
    \[ \epsilon, b, c, bc, \cdots \]
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Algorithm for Running NA}
    \begin{block}{General Idea}
      Searching paths in a finite graph in general requires a lot of computational resources. However, we do not need to output the whole path, thus we only keep track of how states transform.
    \end{block}\pause

    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          {\color{green} 1} \& 2 \\
          3 \& 4
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([ba],1)$. 
    }
    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& {\color{green}2} \\
          {\color{green}3} \& 4
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),([ba],2)$. 
    }
    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& {\color{green}2} \\
          {\color{green}3} \& {\color{green}4}
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),([a],2),([ba],4)$.
    }
    \only<+>{
      Say we run the input $bca$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& 2 \\
          {\color{green}3} \& {\color{green}4}
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),{\color{red}([],3)},([a],4),([ba],4)$.
    }
  \end{frame}
  
  \begin{frame}[fragile]
    \frametitle{Haskell Implementation of Semantics for NA}
    The function \texttt{runNA} is defined as follows:
    \begin{code}
runNA :: (Alphabet l, Ord s) => 
         NDetAut l s  -> s -> [l] -> [([l], s)]
runNA na st input = 
  case input of
    [] -> ([],) <$> epReachable (ndelta na) st
    (w:ws) -> concatMap (\s -> runNA na s input) nsucc ++
              case wsucc of
                [] -> [(input,st)]
                ls -> concatMap (\s -> runNA na s ws) ls
      where wsucc = ndelta na (Just w) st
    where   nsucc = ndelta na Nothing  st
    \end{code}
    Here the function \texttt{epReachable} calculates all the states that is reachable from the current state via $\epsilon$-transitions.
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Equivalence between DA and NA}
    Evidently, any DA is a NA. On the other hand, we can simulate running NA deterministically, basically via the same idea as \texttt{runNA}:

    \begin{itemize}
      \item States are subsets of states of a NA.
      \item A subset is accepting iff it contains some accepting state.
      \item Under an input $l$, a subset transforms to those states reachable from some state via $l$ (with $\epsilon$-transitions). 
    \end{itemize}
  \end{frame}


  \begin{frame}[fragile]
    \frametitle{Haskell Implementation}
    \begin{code}
fromNA :: (Alphabet l, Ord s) => 
          NDetAut l s -> DetAut l (Set.Set s)
fromNA nda = DA { states = Set.toList dasts
                , accept = Set.toList $ Set.filter acchelp dasts
                , delta = fromTransNA ntrans
                }
  where ndasts = nstates nda
        dasts  = Set.powerSet $ Set.fromList ndasts
        ndaacc = naccept nda
        acchelp set = not $ Set.disjoint set 
                          $ Set.fromList ndaacc
        ntrans = ndelta nda

fromTransNA :: (Alphabet l, Ord s) => 
               (Maybe l -> s -> [s]) -> l -> Set.Set s -> Set.Set s
fromTransNA ntrans sym set = result
  where starts = listUnions (epReachable ntrans) set
        step = listUnions (ntrans $ Just sym) starts
        result = listUnions (epReachable ntrans) step
        listUnions f input = Set.unions $ Set.map Set.fromList $ Set.map f input
    \end{code}
  \end{frame}


\section{Kleene's Theorem}
\begin{frame}{The Theorem}
	\large
	\begin{theorem}
		Every regular expression corresponds to a non-deterministic automata and vice-versa
	\end{theorem}
\end{frame}

\begin{frame}{Regular Expression to Automata}
	\makebox[\textwidth][c]{
		\begin{tikzpicture}[
			onenode/.style={rectangle, draw=blue!60, fill=blue!5, thin, minimum size=7mm},
			threenode/.style={rectangle, draw=magenta!60, fill=magenta!5, thin, minimum size=5mm},
			twonode/.style={rectangle, draw=cyan!60, fill=cyan!5, thin, minimum size=5mm},
			fournode/.style={rectangle, draw=green!60, fill=green!5, thin, minimum size=5mm},
			]
			%Nodes
			\node[onenode]      (one)                              {Regular expression are built inductively};
			\node[twonode]        (two)       [below=of one] {Define a way to build autmata inductively};
			\node[threenode]      (three)       [below=of two] {Base Cases};
			\node[fournode]        (four)       [below=of three] {Each regex constructor $\rightarrow$ a way to nicely \textit{glue} automata together};
			
			%Lines
			\draw[->] (one.south) -- (two.north);
			\draw[->] (two.south) -- (three.north);
			\draw[->] (three.south) -- (four.north);
		\end{tikzpicture}
	}
\end{frame}


\begin{frame}{Base Cases}
	\large
	\begin{enumerate}[]\item \boxed{\texttt{Empty:}} A single non-accepting state.
		\item \boxed{\texttt{Epsilon:}} A single accepting state. 
		\item \boxed{\texttt{L a:}} A non-accepting state connected to an accepting one by $a$.
	\end{enumerate}
\end{frame}

\begin{frame}{Inductive Vibes}
	\large
	Given two (one) automata and a regular expression constructor, make a new automaton
	\begin{enumerate}[]
		\item \boxed{\texttt{Seq:}} Attach both automata end to end.
		\item \boxed{\texttt{Alt}} Attach both automata in parralel (with new initial and final states).
		\item \boxed{\texttt{Star}} Fold the automata in a circle around a new initial/final state.
	\end{enumerate}
\end{frame}

\begin{frame}{Interesting Implementation}
	\large
	\begin{enumerate}[]
		\item New states $\rightarrow$ consistent labeling $\rightarrow$ primes!
		\item Epsilon transitions guarantee transition function fidelity (Outputs a NA). 
		
	\end{enumerate}
\end{frame}

\begin{frame}{Automata to Regular Expression}
	\centering \Large
	
	Too much to give an understandable dive into the algorithm
	
	\vspace{5mm}
	
	Summary of algorithm
	
	\vspace{5mm}
	
	Highlight some implementation
	
	\vspace{5mm}
	
	Problems and Future Work
\end{frame}

\begin{frame}{Kleene's Algorithim}
	\centering\Large
	Also known as State-Elimination
	
	\vspace{5mm}
	
	Goal: Recursively deconstruct an automata to get a regex
	
	\vspace{5mm}
	
	Easy to implement - Haskell likes recursion!
	
	\vspace{5mm}
	
	Quick Blackboard Example
	
\end{frame}

\begin{frame}[fragile]{Implementation}
	\large
	\begin{center}Need to relabel an automata onto integers 
	\end{center}
	\begin{code}
		
		relabelHelp :: Ord s => AutData l s -> s -> Int
		relabelHelp aut s = fromJust (Map.lookup s (Map.fromList $ zip (stateData aut) [0..(length (stateData aut))]))
		
		relabelAut :: Ord s => (AutData l s, s) -> RgxAutData l 
		relabelAut (aut, s1) = (AD 
		[relabelHelp aut s | s <- stateData aut] 
		[relabelHelp aut s| s<- acceptData aut] 
		[(relabelHelp aut s, [ (a, relabelHelp aut b)| (a,b) <- aut `transOf` s] ) | s<- stateData aut] 
		,relabelHelp aut s1)
		
	\end{code}
	
\end{frame}

\begin{frame}{Problems}
	\centering\Large
	
	Outputs highly unsimplified regex - hard to simplify
	
	\vspace{5mm}
	
	Explodes when converting aut $\rightarrow$regex$\rightarrow$aut or vice-versa
	
	\vspace{5mm}
	
	VERY SLOW
\end{frame}

\begin{frame}{Future Work}
	\centering\Large
	
	Construct minimal DA from regex to prove algorithm validates Kleene's Theorem
	
	\vspace{5mm}
	
	Further simplify regular expressions (commutativity?)
	
	\vspace{5mm}
	
	Test other algorithms and compare with Kleene's
\end{frame}
\end{document}
