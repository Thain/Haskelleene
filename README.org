q#+TITLE: Haskelleene

Final project and report for Functional Programming Course. Implementation of finite automata, regular expressions, and Kleene algebra within Haskell; in particular an algorithm for converting between automata and regular expressions, and vice versa.

* The Plan

For the state implementation, thinking of using a variant of the "turnstile" construction used on the [[https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State][State Monad Haskell wikibooks page]].

** Defining things

*** DFAs
*** NFAs
*** regexes

** Semantics
*** DFA semantics

*** NFA semantics

*** Regex semantics

*** QuickCheck Semantics

** Translating (Aut <-> Regex)
*** Power-set Construction
*** QuickCheck Determinisation Equivalence

*** "Lift" from DFAs to NFAs
*** Floyd-Warshall Algorithm (Aut -> Regex)

A reachability algorithm ([[https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm][wikipedia]]) to determine the shortest paths between vertices in a graph. The plan is to use it to create a regular expression representing a given automaton.

Closely related to Kleene's algorithm ([[https://en.wikipedia.org/wiki/Kleene%27s_algorithm][wikipedia]]) for creating a regular expression from an automaton.

*** Going the other way (Regex -> Aut)

*** QuickCheck mutual inverses

by generating both automata and regexes, and running both constructions in sequence to see if we get an equivalent thing.

*** QuickCheck language equivalence

For a randomly generated automata and the regex it gets, as well as for a regex and the automata it gets.

** Kleene algebra

a proof system for reasoning about equality of regular expressions.

*** Define proof system

see Malvin's notes on Tableaux from May 06 lecture.

* Notes from template README

See [[report.pdf][report.pdf]] for documentation.

Note: To rename the project you need to replace all occurrences of "report" with your own library name in the following files:

- `hie.yaml`
- `package.yaml`

