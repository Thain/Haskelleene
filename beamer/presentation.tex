\documentclass{beamer}
\input{prelude.tex}
\UseRawInputEncoding

\title{Haskelleene}
\subtitle{a very Haskell implmentation of automata, \\ regular expressions, and Kleene's algorithm}
\author{Liam Chung, Brendan Dufty, Lingyuan Ye}
\date{31st May, 2024}

\AtBeginSection[] {
\begin{frame}{Table of Contents}
\begin{columns}[t]
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={1-4}, currentsection, hideallsubsections]
 \end{column}
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={5-8}, currentsection, hideallsubsections]
 \end{column}
\end{columns}
\end{frame}
}

\begin{document}
\frame{\titlepage}

\begin{frame}{Table of Contents}
\begin{columns}[t]
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={1-4}, hideallsubsections]
 \end{column}
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={5-8}, hideallsubsections]
 \end{column}
\end{columns}
\end{frame}

\section{Introduction}
\begin{frame}{Introduction}
    \begin{quote}
        "Automata are pretty cool."
    \end{quote}
    - Liam Chung
\end{frame}

\begin{frame}[fragile]{What is an automaton?}
An basic version of a state machine. It takes inputs from some \emph{alphabet}, moving between \emph{states} that may or may not \emph{accept}. 
  \begin{verbatim}
  data DetAut l s = DA { states :: [s]
                       , accept :: [s]
                       , delta  :: l -> s -> s }

  data NDetAut l s = NA { nstates :: [s]
                        , naccept :: [s]
                        , ndelta :: Maybe l -> s -> [s] }
  \end{verbatim}\pause
  \[\begin{tikzcd}
  	1 & 2^{\star}
  	\arrow["b", from=1-1, to=1-1, loop, in=150, out=210, distance=5mm]
  	\arrow["a", curve={height=-6pt}, from=1-1, to=1-2]
  	\arrow["b", curve={height=-6pt}, from=1-2, to=1-1]
  	\arrow["a", from=1-2, to=1-2, loop, in=330, out=30, distance=5mm]
      \end{tikzcd}\]\pause
    \textbf{How do we encode \texttt{delta}?}
\end{frame}

\begin{frame}[fragile]{Automaton data: \texttt{AutData}}
  A simpler representation of our data:
  \begin{verbatim}
  type TDict l s = [(s, [(Maybe l, s)])]
  data AutData l s = AD { stateData :: [s] 
                        , acceptData :: [s] 
                        , transitionData :: TDict l s }
  \end{verbatim}
  Then, encode this data into our nicer types. \\ \pause
  Need to check if data is safe for DAs! \textbf{How?}
\end{frame}
\begin{frame}{The \texttt{Alphabet}}
\end{frame}
\begin{frame}{Implementing semantics}
\end{frame}

\section{Non-deterministic Automata}
\begin{frame}{What is a non-deterministic automaton?}
\end{frame}
\begin{frame}{Implementing semantics}
\end{frame}
\begin{frame}{The power set construction}
\end{frame}

\section{Regular Expressions}
\begin{frame}{What is a regular expression?}
\end{frame}
\begin{frame}{Implementing semantics}
\end{frame}
\begin{frame}{\texttt{Seq} and \texttt{Star} cases}
\end{frame}

\section{Finite Automata}
  \begin{frame}
    \frametitle{Deterministic Automata}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Non-Deterministic Automata}
    For non-deterministic automata (NA), the transition for an input gives a \emph{list} of next states, and we also allow empty input. \pause
    
    For instance, the following represents a NA:
    \[
      \begin{tikzcd}
        1 & 2 \\
        3 & 4
        \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
        \arrow["b"{description}, from=1-1, to=2-1]
        \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
        \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
        \arrow["a"{description}, from=1-2, to=2-1]
        \arrow["\epsilon"{description}, from=1-2, to=2-2] 
      \end{tikzcd}
    \]
    \vspace{-\baselineskip} \pause

    Our Haskell implementation of the type of NA:
    \begin{showCode}
data NDetAut l s = NA { nstates :: [s]
                      , naccept :: [s]
                      , ndelta :: Maybe l -> s -> [s] }
    \end{showCode}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Semantics of Non-Deterministic Automata}
    \begin{definition}
      A NA accepts an input string $u$ if there is a \emph{possible} path that terminates at an accepting state.
    \end{definition} \pause

    Suppose the initial state is 1, and the only accepting state is 4:
    \[
      \begin{tikzcd}
        1 & 2 \\
        3 & {\color{red} 4}
        \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
        \arrow["b"{description}, from=1-1, to=2-1]
        \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
        \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
        \arrow["a"{description}, from=1-2, to=2-1]
        \arrow["\epsilon"{description}, from=1-2, to=2-2] 
      \end{tikzcd}
    \]
    Then this NA accepts 
    \[ \epsilon, b, c, bc, \cdots \]
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Algorithm for Running NA}
    \begin{block}{General Idea}
      Searching paths in a finite graph in general requires a lot of computational resources. However, we do not need to output the whole path, thus we only keep track of how states transform.
    \end{block}\pause

    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          {\color{green} 1} \& 2 \\
          3 \& 4
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([ba],1)$. 
    }
    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& {\color{green}2} \\
          {\color{green}3} \& 4
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),([ba],2)$. 
    }
    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& {\color{green}2} \\
          {\color{green}3} \& {\color{green}4}
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),([a],2),([ba],4)$.
    }
    \only<+>{
      Say we run the input $bca$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& 2 \\
          {\color{green}3} \& {\color{green}4}
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),{\color{red}([],3)},([a],4),([ba],4)$.
    }
  \end{frame}
  
  \begin{frame}[fragile]
    \frametitle{Haskell Implementation of Semantics for NA}
    The function \texttt{runNA} is defined as follows:
    \begin{code}
runNA :: (Alphabet l, Ord s) => 
         NDetAut l s  -> s -> [l] -> [([l], s)]
runNA na st input = 
  case input of
    [] -> ([],) <$> epReachable (ndelta na) st
    (w:ws) -> concatMap (\s -> runNA na s input) nsucc ++
              case wsucc of
                [] -> [(input,st)]
                ls -> concatMap (\s -> runNA na s ws) ls
      where wsucc = ndelta na (Just w) st
    where   nsucc = ndelta na Nothing  st
    \end{code}
    Here the function \texttt{epReachable} calculates all the states that is reachable from the current state via $\epsilon$-transitions.
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Equivalence between DA and NA}
    Evidently, any DA is a NA. On the other hand, we can simulate running NA deterministically, basically via the same idea as \texttt{runNA}:

    \begin{itemize}
      \item States are subsets of states of a NA.
      \item A subset is accepting iff it contains some accepting state.
      \item Under an input $l$, a subset transforms to those states reachable from some state via $l$ (with $\epsilon$-transitions). 
    \end{itemize}
  \end{frame}


  \begin{frame}[fragile]
    \frametitle{Haskell Implementation}
    \begin{code}
fromNA :: (Alphabet l, Ord s) => 
          NDetAut l s -> DetAut l (Set.Set s)
fromNA nda = DA { states = Set.toList dasts
                , accept = Set.toList $ Set.filter acchelp dasts
                , delta = fromTransNA ntrans
                }
  where ndasts = nstates nda
        dasts  = Set.powerSet $ Set.fromList ndasts
        ndaacc = naccept nda
        acchelp set = not $ Set.disjoint set 
                          $ Set.fromList ndaacc
        ntrans = ndelta nda

fromTransNA :: (Alphabet l, Ord s) => 
               (Maybe l -> s -> [s]) -> l -> Set.Set s -> Set.Set s
fromTransNA ntrans sym set = result
  where starts = listUnions (epReachable ntrans) set
        step = listUnions (ntrans $ Just sym) starts
        result = listUnions (epReachable ntrans) step
        listUnions f input = Set.unions $ Set.map Set.fromList $ Set.map f input
    \end{code}
  \end{frame}

\section{Kleene's Theorem}
\begin{frame}{Kleene's Theorem}
  \begin{theorem}
    The following are equivalent, for a language $l \in \mathcal{P}(X)$:
    \begin{itemize}
      \item it is represented by a state in a finite DA\pause
      \item it is represented by a state in a finite NA\pause
      \item it is represented by a regular expression\pause
    \end{itemize}
    in such a case, the language $l$ is called \textbf{regular}.
  \end{theorem}
\end{frame}

\end{document}
