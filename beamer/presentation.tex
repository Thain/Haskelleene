\documentclass{beamer}
\input{prelude.tex}
\UseRawInputEncoding

\title{Haskelleene}
\subtitle{a very Haskell implmentation of automata, \\ regular expressions, and Kleene's algorithm}
\author{Liam Chung, Brendan Dufty, Lingyuan Ye}
\date{31st May, 2024}

\AtBeginSection[] {
\begin{frame}{Table of Contents}
\begin{columns}[t]
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={1-4}, currentsection, hideallsubsections]
 \end{column}
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={5-8}, currentsection, hideallsubsections]
 \end{column}
\end{columns}
\end{frame}
}

\begin{document}
\frame{\titlepage}

\begin{frame}{Table of Contents}
\begin{columns}[t]
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={1-4}, hideallsubsections]
 \end{column}
 \begin{column}{.5\textwidth}
     \tableofcontents[sections={5-8}, hideallsubsections]
 \end{column}
\end{columns}
\end{frame}

\section{Introduction}
\begin{frame}{Introduction}
    \begin{quote}
        "Automata are pretty cool."
    \end{quote}
    - Liam Chung
\end{frame}

\section{Finite Automata}
\begin{frame}[fragile]{What is an automaton?}
An basic version of a state machine. It takes inputs from some \emph{alphabet}, moving between \emph{states} that may or may not \emph{accept}. 
  \begin{code}
  data DetAut l s = DA { states :: [s]
                       , accept :: [s]
                       , delta  :: l -> s -> s }

  data NDetAut l s = NA { nstates :: [s]
                        , naccept :: [s]
                        , ndelta :: Maybe l -> s -> [s] }
\end{code}\pause
\begin{itemize}
\item a state in a deterministic automaton accepts a word if that words leads to an accepting state. \pause

\item a state in a non-deterministic automaton accepts a word if \emph{there exists a path} to an accepting state.

\end{itemize}
\end{frame}

  \begin{frame}[fragile]
    \frametitle{Examples}
  A deterministic automaton:
  \[\begin{tikzcd}
  	1 & 2^{\star}
  	\arrow["b", from=1-1, to=1-1, loop, in=150, out=210, distance=5mm]
  	\arrow["a", curve={height=-6pt}, from=1-1, to=1-2]
  	\arrow["b", curve={height=-6pt}, from=1-2, to=1-1]
  	\arrow["a", from=1-2, to=1-2, loop, in=330, out=30, distance=5mm]
      \end{tikzcd}\]\pause
  A non-deterministic one:
    \[
      \begin{tikzcd}
        1 & 2 \\
        3 & 4^{\star}
        \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
        \arrow["b"{description}, from=1-1, to=2-1]
        \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
        \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
        \arrow["a"{description}, from=1-2, to=2-1]
        \arrow["\epsilon"{description}, from=1-2, to=2-2] 
      \end{tikzcd}
    \]
  \end{frame}

  \begin{frame}[fragile]{Algorithm for Running DAs}
    Given an automaton, a starting state, and an input word\ldots

    \begin{code}
run :: DetAut l s -> s -> [l] -> s 
run _ s0 [] = s0 
run da s0 (w:ws) = run da (delta da w s0) ws 
 
acceptDA :: (Eq s) => DetAut l s -> s -> [l] -> Bool 
acceptDA da s0 w = run da s0 w `elem` accept da
    \end{code}\pause \vspace{1em}
    \ldots it's that simple! Mostly due to how much work we put into encoding automata. \vspace{1em} \pause

    Unfortunately, running NAs is less simple. 
    
  \end{frame}
  
  \begin{frame}[fragile]
    \frametitle{Algorithm for Running NAs}
    \begin{block}{General Idea}
      Searching paths in a finite graph in general requires a lot of computational resources. However, we do not need to output the whole path, thus we only keep track of how states transform.
    \end{block}\pause

    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          {\color{green} 1} \& 2 \\
          3 \& 4
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([ba],1)$. 
    }
    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& {\color{green}2} \\
          {\color{green}3} \& 4
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),([ba],2)$. 
    }
    \only<+>{
      Say we run the input $ba$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& {\color{green}2} \\
          {\color{green}3} \& {\color{green}4}
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),([a],2),([ba],4)$.
    }
    \only<+>{
      Say we run the input $bca$ on the previous example:
      \[
        \begin{tikzcd}[ampersand replacement = \&]
          1 \& 2 \\
          {\color{green}3} \& {\color{green}4}
          \arrow["\epsilon"{description}, shift left=2, from=1-1, to=1-2]
          \arrow["b"{description}, from=1-1, to=2-1]
          \arrow["c"{description}, shift left=2, from=1-2, to=1-1]
          \arrow["b"{description}, from=1-2, to=1-2, loop, in=60, out=120, distance=5mm]
          \arrow["a"{description}, from=1-2, to=2-1]
          \arrow["\epsilon"{description}, from=1-2, to=2-2] 
        \end{tikzcd}
      \]
      Active states: $([a],3),{\color{red}([],3)},([a],4),([ba],4)$.
    }
  \end{frame}
  
  \begin{frame}[fragile]
    \frametitle{Haskell Implementation of Semantics for NA}
    The function \texttt{runNA} is defined as follows:
    \begin{code}
runNA :: (Alphabet l, Ord s) => 
         NDetAut l s  -> s -> [l] -> [([l], s)]
runNA na st input = 
  case input of
    [] -> ([],) <$> epReachable (ndelta na) st
    (w:ws) -> concatMap (\s -> runNA na s input) nsucc ++
              case wsucc of
                [] -> [(input,st)]
                ls -> concatMap (\s -> runNA na s ws) ls
      where wsucc = ndelta na (Just w) st
    where   nsucc = ndelta na Nothing  st
    \end{code}
    Here the function \texttt{epReachable} calculates states reachable from the current one via $\epsilon$-transitions.
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Equivalence between DA and NA}
    Evidently, any DA is a NA. On the other hand, we can simulate running NA deterministically, basically via the same idea as \texttt{runNA}:

    \begin{itemize}
      \item States are subsets of states of a NA.
      \item A subset is accepting iff it contains some accepting state.
      \item Under an input $l$, a subset transforms to those states reachable from some state via $l$ (with $\epsilon$-transitions). 
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Haskell Implementation}
    \begin{code}
fromNA :: (Alphabet l, Ord s) => 
          NDetAut l s -> DetAut l (Set.Set s)
fromNA nda = DA { states = Set.toList dasts
                , accept = Set.toList $ Set.filter acchelp dasts
                , delta = fromTransNA ntrans
                }
  where ndasts = nstates nda
        dasts  = Set.powerSet $ Set.fromList ndasts
        ndaacc = naccept nda
        acchelp set = not $ Set.disjoint set 
                          $ Set.fromList ndaacc
        ntrans = ndelta nda

fromTransNA :: (Alphabet l, Ord s) => 
               (Maybe l -> s -> [s]) -> l -> Set.Set s -> Set.Set s
fromTransNA ntrans sym set = result
  where starts = listUnions (epReachable ntrans) set
        step = listUnions (ntrans $ Just sym) starts
        result = listUnions (epReachable ntrans) step
        listUnions f input = Set.unions $ Set.map Set.fromList $ Set.map f input
    \end{code}
  \end{frame}


\section{Regular Expressions}
\begin{frame}[fragile]{What is a regular expression?}

  A ``finite representation'' of a potentially infinite language:

  \begin{code}
data Regex l = Empty | 
               Epsilon |
               L l | 
               Alt (Regex l) (Regex l) |
               Seq (Regex l) (Regex l) |
               Star (Regex l)
  deriving (Eq, Show)
  \end{code} \vspace{1em}
  \textbf{N.B.} not the same as the commonly known, ``programmer's'' regular expression!

\end{frame}

\begin{frame}[fragile]{Implementing semantics}

  How to check if a word is in the language described by a \texttt{Regex}?

  \begin{code}
regexAccept :: Eq l => Regex l -> [l] -> Bool
-- the empty language accepts no words
regexAccept Empty _    = False
-- if down to empty string, only accept empty word
regexAccept Epsilon [] = True  
regexAccept Epsilon _  = False
-- if down to a single letter, only accept that letter 
regexAccept (L _) []   = False
regexAccept (L l) [c]  = l == c
regexAccept (L _) _    = False
regexAccept (Alt r r') cs =
                 regexAccept r cs || regexAccept r' cs
...
\end{code} \vspace

These cases are not so bad!
\end{frame}
\begin{frame}[fragile]{\texttt{Seq} and \texttt{Star} cases}
\begin{code}
regexAccept (Seq r r') cs = any (regexAccept r' . snd)
                                (initCheck r cs)
regexAccept (Star _) [] = True
regexAccept (Star r) cs = 
  any (regexAccept (Star r) . snd) $ ignoreEmpty $ initCheck r cs
  where ignoreEmpty = if regexAccept r [] then init else id 

\end{code}
\end{frame}


\section{Kleene's Theorem}
\begin{frame}{Kleene's Theorem}
  \begin{theorem}
    The following are equivalent, for a language $l \in \mathcal{P}(X)$:
    \begin{itemize}
      \item it is represented by a state in a finite DA\pause
      \item it is represented by a state in a finite NA\pause
      \item it is represented by a regular expression\pause
    \end{itemize}
    in such a case, the language $l$ is called \textbf{regular}.
  \end{theorem}
\end{frame}

\end{document}
